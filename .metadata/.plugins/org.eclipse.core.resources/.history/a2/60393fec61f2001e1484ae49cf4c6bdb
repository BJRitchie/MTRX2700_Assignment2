
#include "timer.h"
#include "stm32f303xc.h"

struct _HardwareTimer {
	TIM_TypeDef *TIMx;
	volatile uint16_t PrescaleValue;// prescaler value
	volatile uint32_t ARRValue; 	// prescaler value
	volatile uint32_t MaskAPB2ENR;	// mask to enable RCC APB2 bus registers
	volatile uint32_t MaskAPB1ENR;	// mask to enable RCC APB1 bus registers
	volatile uint32_t MaskAHBENR;	// mask to enable RCC AHB bus registers
	volatile uint32_t MaskCR1; 		// mask to apply to CR1 (control reg 1)
	volatile uint32_t MaskDIER; 	// mask to apply to DIER (DMA/interrupt enable register)
	void (*completion_function)(uint32_t);
};

HardwareTimer TIM2_init = {
		TIM2,
		0, 					// prescaler
		8000, 				// overflow value
		0x00, 				// bit to enable APB2 bus
		RCC_APB1ENR_TIM2EN, // bit to enable APB1 bus
		RCC_AHBENR_TIM2EN, 	// bit to enable for AHB bus
		TIM_CR1_URS, 		// bit for CR1 reg; interrupt only flagged at over/underflow
		TIM_DIER_UIE, 		// enable update interrupt
		0X00				// default function pointer is NULL
};

// initialise a hardware timer
void TimerInitialise(HardwareTimer *hardware_timer, void (*completion_function)(uint32_t)) {

	// set completion function
	hardware_timer->completion_function = completion_function;

    // Enable clock
    RCC->APB1ENR |= hardware_timer->MaskAPB1ENR;

    // set prescaler
    hardware_timer->TIMx->PSC = hardware_timer->PrescaleValue;

    // set auto reload register
    hardware_timer->TIMx->ARR = hardware_timer->ARRValue;

    // set CR1 mask
    hardware_timer->TIMx->CR1 |= hardware_timer->MaskCR1;

    // set DIER mask
    hardware_timer->TIMx->DIER |= hardware_timer->MaskDIER;

    // start TIMx
    hardware_timer->TIMx->CR1 |= TIM_CR1_CEN;
}

// enable the timer overflow interrupt
void enable_timer_interrupt() {
    // disable interrupts
	__disable_irq();

	NVIC_SetPriority(TIM2_IRQn, 1); // Set priority
    NVIC_EnableIRQ(TIM2_IRQn); 		// Enable TIM2 IRQ

    // re-enable interrupts
    __enable_irq();
}








//
///* function to initialise the timer with interrupt at overflow
// * Inputs:
// * - int period: desired period between actions in milliseconds
// *
// * Outputs:
// * - None */
//void TIM2_interrupt_init(uint32_t period)
//{
//	// disable other interrupts while initialising
//	__disable_irq();
//
//    // Enable TIM2 clock
//    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
//
//    // Configure TIM2
//    TIM2->PSC = 8000 - 1; 			// Set prescaler, clock speed is now 1kHz
//    TIM2->ARR = period; 			// Set auto-reload value
//    TIM2->CR1 |= TIM_CR1_URS; 		// interrupt only flagged at over/underflow
//    TIM2->DIER |= TIM_DIER_UIE; 	// Enable update interrupt
//    NVIC_SetPriority(TIM2_IRQn, 1); // Set priority
//    NVIC_EnableIRQ(TIM2_IRQn); 		// Enable TIM2 IRQ
//
//    // Start TIM2
//    TIM2->CR1 |= TIM_CR1_CEN;
//
//	// Re-enable all interrupts (now that we are finished)
//	__enable_irq();
//}
